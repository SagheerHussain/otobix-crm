// // services/fcm_service.dart
// import 'dart:async';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:firebase_core/firebase_core.dart';
// import 'package:firebase_messaging/firebase_messaging.dart';
// import 'package:flutter_local_notifications/flutter_local_notifications.dart';

// import '../firebase_options.dart'; // generated by `flutterfire configure`

// /// Top-level background handler (required by firebase_messaging)
// @pragma('vm:entry-point')
// Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
//   // Ensure Firebase is initialized in background isolates
//   await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
//   // You can add logging/analytics here if needed.
// }

// /// Centralized service to handle:
// /// - Firebase initialization
// /// - Notification permissions
// /// - Token management & refresh
// /// - Foreground display via flutter_local_notifications
// /// - onMessage / onMessageOpenedApp listeners
// class FCMService {
//   FCMService._();
//   static final FCMService instance = FCMService._();

//   final FirebaseMessaging _messaging = FirebaseMessaging.instance;
//   final FlutterLocalNotificationsPlugin _local =
//       FlutterLocalNotificationsPlugin();

//   /// Current FCM token (nullable until fetched)
//   String? _token;
//   String? get token => _token;

//   /// Stream for token updates (e.g., to sync with backend)
//   final StreamController<String> _tokenController =
//       StreamController.broadcast();
//   Stream<String> get tokenStream => _tokenController.stream;

//   /// Stream for notification taps (deep links/navigation)
//   final StreamController<RemoteMessage> _tapController =
//       StreamController.broadcast();
//   Stream<RemoteMessage> get onNotificationTap => _tapController.stream;

//   bool _initialized = false;

//   /// Call once at app startup (before runApp is fine)
//   Future<void> initialize() async {
//     if (_initialized) return;
//     _initialized = true;

//     // 1) Firebase
//     await Firebase.initializeApp(
//       options: DefaultFirebaseOptions.currentPlatform,
//     );

//     // 2) Background handler
//     FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

//     // 3) Local notifications (for foreground display)
//     await _initLocalNotifications();

//     // 4) iOS foreground presentation (badges/alerts/sounds while in-app)
//     await _messaging.setForegroundNotificationPresentationOptions(
//       alert: true,
//       badge: true,
//       sound: true,
//     );

//     // 5) Permissions (iOS + Android 13+)
//     await _requestNotificationPermission();

//     // 6) Token + refresh
//     _token = await _messaging.getToken();
//     // after: _token = await _messaging.getToken();
//     if (_token != null) {
//       _tokenController.add(_token!);
//       debugPrint('ðŸ”‘ FCM token: $_token'); // <â€” copy this from your logs
//     }

//     await subscribeToTopic('all'); // now /notify/topic hits this device

//     _messaging.onTokenRefresh.listen((t) {
//       _token = t;
//       _tokenController.add(t);
//     });

//     // 7) Foreground messages â†’ show banner via local notifications
//     FirebaseMessaging.onMessage.listen(_handleForegroundMessage);

//     // 8) User taps on notification (opened app from background/terminated)
//     FirebaseMessaging.onMessageOpenedApp.listen(_tapController.add);

//     // If the app was launched by tapping a notification while app was terminated
//     final initialMessage = await _messaging.getInitialMessage();
//     if (initialMessage != null) {
//       // Delay a frame so listeners can subscribe
//       Future.microtask(() => _tapController.add(initialMessage));
//     }
//   }

//   // ------------------------ Internal helpers ------------------------

//   Future<void> _initLocalNotifications() async {
//     // Android
//     const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
//     // iOS
//     const iosInit = DarwinInitializationSettings();
//     const initSettings = InitializationSettings(
//       android: androidInit,
//       iOS: iosInit,
//     );
//     await _local.initialize(initSettings);

//     // Create a default high-importance channel on Android
//     const channel = AndroidNotificationChannel(
//       'high_importance_channel',
//       'High Importance Notifications',
//       description: 'Used for important notifications.',
//       importance: Importance.max,
//     );

//     await _local
//         .resolvePlatformSpecificImplementation<
//           AndroidFlutterLocalNotificationsPlugin
//         >()
//         ?.createNotificationChannel(channel);
//   }

//   Future<void> _requestNotificationPermission() async {
//     // This prompts on iOS (and is a no-op on older Androids).
//     await _messaging.requestPermission(alert: true, badge: true, sound: true);
//   }

//   void _handleForegroundMessage(RemoteMessage message) {
//     final n = message.notification;
//     if (n == null) return;

//     _local.show(
//       n.hashCode,
//       n.title,
//       n.body,
//       const NotificationDetails(
//         android: AndroidNotificationDetails(
//           'high_importance_channel',
//           'High Importance Notifications',
//           channelDescription: 'Used for important notifications.',
//           importance: Importance.max,
//           priority: Priority.high,
//         ),
//         iOS: DarwinNotificationDetails(),
//       ),
//       payload: _encodePayload(message.data),
//     );
//   }

//   String? _encodePayload(Map<String, dynamic> data) {
//     if (data.isEmpty) return null;
//     try {
//       return data.entries.map((e) => '${e.key}=${e.value}').join('&');
//     } catch (_) {
//       return null;
//     }
//   }

//   /// Subscribe to a topic (optional helper)
//   Future<void> subscribeToTopic(String topic) =>
//       _messaging.subscribeToTopic(topic);

//   /// Unsubscribe from a topic (optional helper)
//   Future<void> unsubscribeFromTopic(String topic) =>
//       _messaging.unsubscribeFromTopic(topic);

//   /// Dispose streams (e.g., on app shutdown/tests)
//   void dispose() {
//     _tokenController.close();
//     _tapController.close();
//   }
// }
